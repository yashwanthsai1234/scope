# User Experience

## The Mental Model

**Scope is not a tool Claude Code uses. Scope is how you run Claude Code.**

Every Claude Code session is a scope session. There's no distinction between "main" and "child"—they're all tracked, all observable, all attachable.

## Installation

One line. No config files, no setup wizards.

```bash
# One-shot run (no install)
uvx scope

# Or install globally
uv tool install scope
scope
```

After install, run `scope setup` to configure Claude Code integration:
- Checks for `tmux` dependency, offers to install if missing
- Hooks installed to `~/.claude/settings.json`
- Documentation added so Claude Code knows how to use it
- No API keys needed (piggybacks on Claude Code's existing auth)

**Auto-launch:** Running `scope` automatically starts tmux if you're not already in it. No need to manually run `tmux` first.

## Human UX: `scope`

The primary interface for humans is a terminal UI that shows all sessions:

```
┌─ scope ───────────────────────────────────────────────────── 3 running ──┐
│                                                                          │
│  ID    Task                          Status    Activity                  │
│  ──────────────────────────────────────────────────────────────────────  │
│▸ ▼ 0   Refactor auth to use JWT      running   waiting on children       │
│    ├ 0.0  Extract JWT helpers        running   editing token.ts          │
│    └ 0.1  Update middleware          done      ─                         │
│  ▶ 1   Write tests for user module   running   running jest              │
│    2   Fix database connection       done      ─                         │
│                                                                          │
├──────────────────────────────────────────────────────────────────────────┤
│  [n]ew  [enter] attach  [x] abort  [d] hide done  [q] quit               │
└──────────────────────────────────────────────────────────────────────────┘
```

### Keybindings

| Key | Action |
|-----|--------|
| `n` | New session (opens split pane with Claude Code) |
| `enter` | Attach to selected session (opens split pane) |
| `x` | Abort selected (and all descendants) |
| `j/k` or `↑/↓` | Navigate sessions |
| `h/l` or `←/→` | Collapse/expand tree |
| `d` | Toggle showing completed sessions |
| `q` | Quit TUI (sessions keep running) |

**Note:** Closing the right pane (Ctrl-D or exit) detaches from the session without stopping it. The session continues running in the background.

### The Flow

**Starting fresh:**
```
┌─ scope ───────────────────────────────────────────────────── 0 sessions ─┐
│                                                                          │
│                         No active sessions                               │
│                                                                          │
│                     Press [n] to start a new session                     │
│                                                                          │
└──────────────────────────────────────────────────────────────────────────┘
```

**User presses `n`**

Scope creates a new session and asks tmux to split a new pane with Claude Code:
```
┌─────────────────────────────────┬────────────────────────────────────────┐
│ ┌─ scope ─────── 1 running ──┐  │                                        │
│ │                            │  │  $ claude                              │
│ │  ID  Task           Status │  │                                        │
│ │  ────────────────────────  │  │  > Refactor the auth module to use    │
│ │▸ 0   (pending...)  running │  │    JWT tokens instead of sessions     │
│ │                            │  │                                        │
│ ├────────────────────────────┤  │                                        │
│ │  [n]ew  [enter]  [q] quit  │  │                                        │
│ └────────────────────────────┘  │                                        │
└─────────────────────────────────┴────────────────────────────────────────┘
```

**After the first prompt, task is inferred:**
```
┌─────────────────────────────────┬────────────────────────────────────────┐
│ ┌─ scope ─────── 1 running ──┐  │                                        │
│ │                            │  │  I'll help you refactor the auth      │
│ │  ID  Task           Status │  │  module to use JWT. Let me start by   │
│ │  ────────────────────────  │  │  reading the current implementation.  │
│ │▸ 0   Refactor auth  running│  │                                        │
│ │                            │  │  Reading src/auth/login.ts...         │
│ ├────────────────────────────┤  │                                        │
│ │  [n]ew  [enter]  [q] quit  │  │                                        │
│ └────────────────────────────┘  │                                        │
└─────────────────────────────────┴────────────────────────────────────────┘
```

The task file is updated with a succinct phrase derived from the user's first message. No upfront prompt needed—just start talking to Claude.

**Session 0's Claude decides to spawn subtasks...**
```
┌─ scope ───────────────────────────────────────────────────── 3 running ──┐
│                                                                          │
│  ID    Task                          Status    Activity                  │
│  ──────────────────────────────────────────────────────────────────────  │
│▸ ▼ 0   Refactor auth to use JWT      running   waiting on children       │
│    ├ 0.0  Extract JWT helpers        running   editing token.ts          │
│    └ 0.1  Update middleware          running   reading middleware.ts     │
│                                                                          │
└──────────────────────────────────────────────────────────────────────────┘
```

### Attach and Detach

When you press `enter` on a running session:
- Scope opens a new tmux split pane attached to that session
- You interact with it like any normal CC session
- To detach, just close the pane—the underlying session keeps running
- Multiple panes can attach to the same session

## Agent UX: How Claude Code Uses Scope

### Discovery

On `scope setup`, scope adds documentation to `~/.local/share/scope/CLAUDE.md`:

```markdown
## scope - Subagent Orchestration

Use `scope` to spawn bounded, purpose-specific subagents that preserve your context.

### When to use
- Task is parallelizable
- Task has clear inputs/outputs
- Task would consume significant context if done inline

### Commands
```bash
scope spawn "<task>" [--input <path>] [--output "<description>"]
# Returns: session ID (e.g., "0" or "0.1")

scope poll <id>
# Returns: JSON {"status": "running|done", "activity": "...", "result": ...}

scope wait <id> [<id2> ...]
# Blocks until complete. Returns: JSON {"results": [...]}
```

### Custom Command: /ralph

Use `/ralph` when you need an iterative critique → improve loop with explicit
stopping criteria. It runs a requirements interview, then coordinates fresh
subagents each iteration until the goal is met or gains taper off.

### Example
```bash
id=$(scope spawn "Write tests for auth module" --input src/auth)
# ... do other work ...
result=$(scope wait $id)
```
```

Claude Code reads this, internalizes it, and uses it like any other CLI tool.

### Programmatic Interface

**Spawn a subagent:**
```bash
scope spawn "Refactor the authentication module" --input src/auth/ --output "summary, file list"
# stdout: 0
```

**Check status (non-blocking):**
```bash
scope poll 0
# stdout: {"status": "running", "activity": "editing token.ts"}
```

**Wait for completion (blocking):**
```bash
scope wait 0
# blocks until done
# stdout: {"status": "done", "result": {...}}
```

**Wait for multiple:**
```bash
scope wait 0 1 2
# blocks until ALL complete
# stdout: {"results": [...]}
```

### Environment-Based Nesting

The lineage is implicit via `SCOPE_SESSION_ID`:

```bash
# User starts fresh (no scope context)
$ scope spawn "Refactor auth"
# SCOPE_SESSION_ID is unset → creates top-level session
# Returns: 0

# Inside session 0, Claude runs:
$ scope spawn "Extract JWT helpers"
# SCOPE_SESSION_ID=0 → creates child session
# Returns: 0.0

# Inside session 0.0:
$ scope spawn "Parse token format"
# SCOPE_SESSION_ID=0.0 → creates grandchild
# Returns: 0.0.0
```

The parent is inferred from the environment.

### The Contract

When a subagent spawns, it receives a contract via system prompt:

```markdown
# Scope Contract (ID: 0)

## Task
Refactor auth module to use JWT

## Working Directory
/project/

## Input
Read and understand: src/auth/

## Output
When complete, write your result to: .scope/sessions/0/result

Keep it token-efficient:
- What you did (brief)
- Key insights or surprises
- Anything the caller needs to know

Skip the obvious. Focus on what matters.

## Notes
- You have full access to the working directory
- Activity tracking is automatic—just do your work
- To spawn a child task: scope spawn "subtask"
```

The subagent knows:
- What it needs to do
- That output should be concise and insight-focused (not verbose JSON)
- That it's scoped (should finish and return, not wander)

### What the Agent Doesn't Do

The agent doesn't track its own activity. That would be fragile.

Instead, hooks fire on every tool call:
- **PostToolUse**: Captures what the agent is currently doing
- **Stop**: Marks the session as complete

The agent's only job is to write `result.json` when done.

## Process Hierarchy

```
User's terminal
└── scope (TUI process)
    └── [monitoring .scope/sessions/]

tmux server (separate process tree)
├── scope-0 (tmux session)
│   └── claude (SCOPE_SESSION_ID=0)
│       ├── [calls scope spawn] ──creates──→ scope-0.0
│       └── [calls scope spawn] ──creates──→ scope-0.1
├── scope-0.0 (tmux session)
│   └── claude (SCOPE_SESSION_ID=0.0)
└── scope-0.1 (tmux session)
    └── claude (SCOPE_SESSION_ID=0.1)
```

`scope` doesn't own the Claude processes—the terminal multiplexer does. `scope` just reads the `.scope/` directory and renders it.

## Command Reference

| Command | User | Purpose |
|---------|------|---------|
| `scope` | Human | Interactive control panel |
| `scope spawn "<task>"` | CC / Human | Start a subagent, get ID |
| `scope poll <id>` | CC | Non-blocking status check |
| `scope wait <id> [...]` | CC | Blocking wait for completion |
| `scope attach <id>` | Human | Attach to a running session |
| `scope abort <id>` | Human | Kill session and descendants |

## Summary

Two interfaces, clearly separated:

**For Claude Code (programmatic):**
- `spawn` → get session ID
- `poll` → check status
- `wait` → block until done

**For the human operator (interactive):**
- `scope` → see everything, attach anywhere, abort when needed

The human sees the forest. Claude Code tends to individual trees.
